/* tslint:disable */
/* eslint-disable */
/**
 * Compliance Framework Configuration Service API
 * This is the API for the Compliance Framework Configuration Service.
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { AxiosInstance, AxiosPromise, AxiosRequestConfig } from "axios";
import globalAxios from "axios";
import type { Configuration } from "./configuration";
// Some imports not used depending on template conditions
// @ts-ignore
import type { RequestArgs } from "./base";
import {
  assertParamExists,
  createRequestFunction,
  DUMMY_BASE_URL,
  serializeDataIfNeeded,
  setSearchParams,
  toPathString,
} from "./common";
// @ts-ignore
import { BaseAPI, BASE_PATH } from "./base";

/**
 *
 * @export
 * @interface ApiError
 */
export interface ApiError {
  /**
   *
   * @type {{ [key: string]: any; }}
   * @memberof ApiError
   */
  errors?: { [key: string]: any };
}
/**
 *
 * @export
 * @interface DomainAction
 */
export interface DomainAction {
  /**
   *
   * @type {string}
   * @memberof DomainAction
   */
  date?: string;
  /**
   *
   * @type {string}
   * @memberof DomainAction
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof DomainAction
   */
  id?: string;
  /**
   *
   * @type {Array<DomainLink>}
   * @memberof DomainAction
   */
  links?: Array<DomainLink>;
  /**
   *
   * @type {Array<DomainProperty>}
   * @memberof DomainAction
   */
  props?: Array<DomainProperty>;
  /**
   *
   * @type {string}
   * @memberof DomainAction
   */
  remarks?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof DomainAction
   */
  responsiblePartyUuids?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof DomainAction
   */
  system?: string;
  /**
   *
   * @type {string}
   * @memberof DomainAction
   */
  title?: string;
  /**
   *
   * @type {string}
   * @memberof DomainAction
   */
  type?: string;
}
/**
 *
 * @export
 * @interface DomainActor
 */
export interface DomainActor {
  /**
   *
   * @type {string}
   * @memberof DomainActor
   */
  description?: string;
  /**
   *
   * @type {Array<DomainLink>}
   * @memberof DomainActor
   */
  links?: Array<DomainLink>;
  /**
   *
   * @type {Array<DomainProperty>}
   * @memberof DomainActor
   */
  props?: Array<DomainProperty>;
  /**
   *
   * @type {string}
   * @memberof DomainActor
   */
  remarks?: string;
  /**
   *
   * @type {string}
   * @memberof DomainActor
   */
  roleId?: string;
  /**
   *
   * @type {string}
   * @memberof DomainActor
   */
  title?: string;
  /**
   *
   * @type {DomainActorType}
   * @memberof DomainActor
   */
  type?: DomainActorType;
  /**
   *
   * @type {string}
   * @memberof DomainActor
   */
  uuid?: string;
}

/**
 *
 * @export
 * @enum {string}
 */

export const DomainActorType = {
  ActorTypeTool: "tool",
  ActorTypeAssessmentPlatform: "assessment-platform",
  ActorTypeParty: "party",
} as const;

export type DomainActorType = (typeof DomainActorType)[keyof typeof DomainActorType];

/**
 *
 * @export
 * @interface DomainAuthorizationBoundary
 */
export interface DomainAuthorizationBoundary {
  /**
   *
   * @type {string}
   * @memberof DomainAuthorizationBoundary
   */
  description?: string;
  /**
   * Diagrams is an optional collection of visual representations of the boundary.
   * @type {Array<DomainDiagram>}
   * @memberof DomainAuthorizationBoundary
   */
  diagrams?: Array<DomainDiagram>;
  /**
   *
   * @type {Array<DomainLink>}
   * @memberof DomainAuthorizationBoundary
   */
  links?: Array<DomainLink>;
  /**
   *
   * @type {Array<DomainProperty>}
   * @memberof DomainAuthorizationBoundary
   */
  props?: Array<DomainProperty>;
  /**
   *
   * @type {string}
   * @memberof DomainAuthorizationBoundary
   */
  remarks?: string;
  /**
   *
   * @type {string}
   * @memberof DomainAuthorizationBoundary
   */
  title?: string;
}
/**
 *
 * @export
 * @interface DomainBackMatter
 */
export interface DomainBackMatter {
  /**
   *
   * @type {Array<DomainResource>}
   * @memberof DomainBackMatter
   */
  resources?: Array<DomainResource>;
}
/**
 *
 * @export
 * @interface DomainBase64
 */
export interface DomainBase64 {
  /**
   * Name of the file before it was encoded as Base64.
   * @type {string}
   * @memberof DomainBase64
   */
  filename?: string;
  /**
   * A label that indicates the nature of a resource.
   * @type {string}
   * @memberof DomainBase64
   */
  "media-type"?: string;
  /**
   * The Base64 encoded value.
   * @type {string}
   * @memberof DomainBase64
   */
  value?: string;
}
/**
 *
 * @export
 * @interface DomainCharacterization
 */
export interface DomainCharacterization {
  /**
   *
   * @type {Array<DomainFacet>}
   * @memberof DomainCharacterization
   */
  facets?: Array<DomainFacet>;
  /**
   *
   * @type {Array<DomainLink>}
   * @memberof DomainCharacterization
   */
  links?: Array<DomainLink>;
  /**
   * Actors / Tasks Identify the source of the finding, such as a tool, interviewed person, or activity
   * @type {Array<string>}
   * @memberof DomainCharacterization
   */
  originActors?: Array<string>;
  /**
   *
   * @type {Array<DomainProperty>}
   * @memberof DomainCharacterization
   */
  props?: Array<DomainProperty>;
  /**
   *
   * @type {Array<string>}
   * @memberof DomainCharacterization
   */
  relatedTasks?: Array<string>;
}
/**
 *
 * @export
 * @interface DomainCitation
 */
export interface DomainCitation {
  /**
   * Links associated with the citation.
   * @type {Array<DomainLink>}
   * @memberof DomainCitation
   */
  links?: Array<DomainLink>;
  /**
   * Properties of the citation.
   * @type {Array<DomainProperty>}
   * @memberof DomainCitation
   */
  props?: Array<DomainProperty>;
  /**
   * A line of citation text.
   * @type {string}
   * @memberof DomainCitation
   */
  text?: string;
}
/**
 *
 * @export
 * @interface DomainDataFlow
 */
export interface DomainDataFlow {
  /**
   *
   * @type {string}
   * @memberof DomainDataFlow
   */
  description?: string;
  /**
   * Description is a summary of the system\'s data flow.
   * @type {Array<DomainDiagram>}
   * @memberof DomainDataFlow
   */
  diagrams?: Array<DomainDiagram>;
  /**
   *
   * @type {Array<DomainLink>}
   * @memberof DomainDataFlow
   */
  links?: Array<DomainLink>;
  /**
   *
   * @type {Array<DomainProperty>}
   * @memberof DomainDataFlow
   */
  props?: Array<DomainProperty>;
  /**
   *
   * @type {string}
   * @memberof DomainDataFlow
   */
  remarks?: string;
  /**
   *
   * @type {string}
   * @memberof DomainDataFlow
   */
  title?: string;
}
/**
 *
 * @export
 * @interface DomainDiagram
 */
export interface DomainDiagram {
  /**
   * Caption provides a brief annotation for the diagram.
   * @type {string}
   * @memberof DomainDiagram
   */
  caption?: string;
  /**
   *
   * @type {string}
   * @memberof DomainDiagram
   */
  description?: string;
  /**
   *
   * @type {Array<DomainLink>}
   * @memberof DomainDiagram
   */
  links?: Array<DomainLink>;
  /**
   *
   * @type {Array<DomainProperty>}
   * @memberof DomainDiagram
   */
  props?: Array<DomainProperty>;
  /**
   *
   * @type {string}
   * @memberof DomainDiagram
   */
  remarks?: string;
  /**
   *
   * @type {string}
   * @memberof DomainDiagram
   */
  title?: string;
  /**
   * Uuid is a machine-oriented, globally unique identifier that can be used to reference this diagram elsewhere in this or other OSCAL instances.
   * @type {string}
   * @memberof DomainDiagram
   */
  uuid?: string;
}
/**
 *
 * @export
 * @interface DomainDocumentIdentifier
 */
export interface DomainDocumentIdentifier {
  /**
   * The document identifier.
   * @type {string}
   * @memberof DomainDocumentIdentifier
   */
  identifier?: string;
  /**
   * Qualifies the kind of document identifier using a URI.
   * @type {any}
   * @memberof DomainDocumentIdentifier
   */
  scheme?: any;
}
/**
 *
 * @export
 * @interface DomainEvidence
 */
export interface DomainEvidence {
  /**
   *
   * @type {string}
   * @memberof DomainEvidence
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof DomainEvidence
   */
  id?: string;
  /**
   *
   * @type {Array<DomainLink>}
   * @memberof DomainEvidence
   */
  links?: Array<DomainLink>;
  /**
   *
   * @type {Array<DomainProperty>}
   * @memberof DomainEvidence
   */
  props?: Array<DomainProperty>;
  /**
   *
   * @type {string}
   * @memberof DomainEvidence
   */
  remarks?: string;
  /**
   *
   * @type {string}
   * @memberof DomainEvidence
   */
  title?: string;
}
/**
 *
 * @export
 * @interface DomainFacet
 */
export interface DomainFacet {
  /**
   *
   * @type {string}
   * @memberof DomainFacet
   */
  description?: string;
  /**
   *
   * @type {Array<DomainLink>}
   * @memberof DomainFacet
   */
  links?: Array<DomainLink>;
  /**
   *
   * @type {string}
   * @memberof DomainFacet
   */
  name?: string;
  /**
   *
   * @type {Array<DomainProperty>}
   * @memberof DomainFacet
   */
  props?: Array<DomainProperty>;
  /**
   *
   * @type {string}
   * @memberof DomainFacet
   */
  remarks?: string;
  /**
   * One of: http://fedramp.gov, http://fedramp.gov/ns/oscal, http://csrc.nist.gov/ns/oscal, http://csrc.nist.gov/ns/oscal/unknown, http://cve.mitre.org, http://www.first.org/cvss/v2.0, http://www.first.org/cvss/v3.0, http://www.first.org/cvss/v3.1
   * @type {string}
   * @memberof DomainFacet
   */
  system?: string;
  /**
   *
   * @type {string}
   * @memberof DomainFacet
   */
  title?: string;
  /**
   *
   * @type {string}
   * @memberof DomainFacet
   */
  value?: string;
}
/**
 *
 * @export
 * @interface DomainFinding
 */
export interface DomainFinding {
  /**
   *
   * @type {string}
   * @memberof DomainFinding
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof DomainFinding
   */
  id?: string;
  /**
   * ImplementationStatementId Reference to the implementation statement in the SSP to which this finding is related.
   * @type {string}
   * @memberof DomainFinding
   */
  implementationStatementId?: string;
  /**
   *
   * @type {Array<DomainLink>}
   * @memberof DomainFinding
   */
  links?: Array<DomainLink>;
  /**
   * Actors / Tasks Identify the source of the finding, such as a tool, interviewed person, or activity Maps to the OSCAL \"origins\" property
   * @type {Array<string>}
   * @memberof DomainFinding
   */
  originActors?: Array<string>;
  /**
   *
   * @type {Array<DomainProperty>}
   * @memberof DomainFinding
   */
  props?: Array<DomainProperty>;
  /**
   *
   * @type {Array<string>}
   * @memberof DomainFinding
   */
  relatedObservations?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof DomainFinding
   */
  relatedRisks?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof DomainFinding
   */
  relatedTasks?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof DomainFinding
   */
  remarks?: string;
  /**
   *
   * @type {string}
   * @memberof DomainFinding
   */
  target?: string;
  /**
   *
   * @type {string}
   * @memberof DomainFinding
   */
  title?: string;
}
/**
 *
 * @export
 * @interface DomainImpact
 */
export interface DomainImpact {
  /**
   *
   * @type {string}
   * @memberof DomainImpact
   */
  adjustment_justification?: string;
  /**
   *
   * @type {string}
   * @memberof DomainImpact
   */
  base?: string;
  /**
   *
   * @type {Array<DomainLink>}
   * @memberof DomainImpact
   */
  links?: Array<DomainLink>;
  /**
   *
   * @type {Array<DomainProperty>}
   * @memberof DomainImpact
   */
  props?: Array<DomainProperty>;
  /**
   *
   * @type {string}
   * @memberof DomainImpact
   */
  selected?: string;
}
/**
 *
 * @export
 * @interface DomainInformationType
 */
export interface DomainInformationType {
  /**
   *
   * @type {DomainImpact}
   * @memberof DomainInformationType
   */
  availability_impact?: DomainImpact;
  /**
   *
   * @type {Array<DomainInformationTypeCategorization>}
   * @memberof DomainInformationType
   */
  categorizations?: Array<DomainInformationTypeCategorization>;
  /**
   *
   * @type {DomainImpact}
   * @memberof DomainInformationType
   */
  confidentiality_impact?: DomainImpact;
  /**
   *
   * @type {string}
   * @memberof DomainInformationType
   */
  description?: string;
  /**
   *
   * @type {DomainImpact}
   * @memberof DomainInformationType
   */
  integrity_impact?: DomainImpact;
  /**
   *
   * @type {Array<DomainLink>}
   * @memberof DomainInformationType
   */
  links?: Array<DomainLink>;
  /**
   *
   * @type {Array<DomainProperty>}
   * @memberof DomainInformationType
   */
  props?: Array<DomainProperty>;
  /**
   *
   * @type {string}
   * @memberof DomainInformationType
   */
  remarks?: string;
  /**
   *
   * @type {string}
   * @memberof DomainInformationType
   */
  title?: string;
  /**
   *
   * @type {string}
   * @memberof DomainInformationType
   */
  uuid?: string;
}
/**
 *
 * @export
 * @interface DomainInformationTypeCategorization
 */
export interface DomainInformationTypeCategorization {
  /**
   * NOTE: This part is a bit blurred
   * @type {Array<string>}
   * @memberof DomainInformationTypeCategorization
   */
  ids?: Array<string>;
  /**
   * This is an enum but right now it has only one value: http://doi.org/10.6028/NIST.SP.800-60v2r1
   * @type {string}
   * @memberof DomainInformationTypeCategorization
   */
  system?: string;
}
/**
 *
 * @export
 * @interface DomainLink
 */
export interface DomainLink {
  /**
   *
   * @type {string}
   * @memberof DomainLink
   */
  href?: string;
  /**
   *
   * @type {string}
   * @memberof DomainLink
   */
  mediaType?: string;
  /**
   *
   * @type {string}
   * @memberof DomainLink
   */
  rel?: string;
  /**
   *
   * @type {string}
   * @memberof DomainLink
   */
  resourceFragment?: string;
  /**
   *
   * @type {string}
   * @memberof DomainLink
   */
  text?: string;
}
/**
 *
 * @export
 * @interface DomainNetworkArchitecture
 */
export interface DomainNetworkArchitecture {
  /**
   *
   * @type {string}
   * @memberof DomainNetworkArchitecture
   */
  description?: string;
  /**
   *
   * @type {Array<DomainDiagram>}
   * @memberof DomainNetworkArchitecture
   */
  diagrams?: Array<DomainDiagram>;
  /**
   *
   * @type {Array<DomainLink>}
   * @memberof DomainNetworkArchitecture
   */
  links?: Array<DomainLink>;
  /**
   *
   * @type {Array<DomainProperty>}
   * @memberof DomainNetworkArchitecture
   */
  props?: Array<DomainProperty>;
  /**
   *
   * @type {string}
   * @memberof DomainNetworkArchitecture
   */
  remarks?: string;
  /**
   *
   * @type {string}
   * @memberof DomainNetworkArchitecture
   */
  title?: string;
}
/**
 *
 * @export
 * @interface DomainObservation
 */
export interface DomainObservation {
  /**
   *
   * @type {string}
   * @memberof DomainObservation
   */
  collected?: string;
  /**
   *
   * @type {string}
   * @memberof DomainObservation
   */
  description?: string;
  /**
   *
   * @type {Array<DomainEvidence>}
   * @memberof DomainObservation
   */
  evidences?: Array<DomainEvidence>;
  /**
   *
   * @type {string}
   * @memberof DomainObservation
   */
  expires?: string;
  /**
   *
   * @type {string}
   * @memberof DomainObservation
   */
  id?: string;
  /**
   *
   * @type {Array<DomainLink>}
   * @memberof DomainObservation
   */
  links?: Array<DomainLink>;
  /**
   *
   * @type {Array<DomainObservationMethod>}
   * @memberof DomainObservation
   */
  methods?: Array<DomainObservationMethod>;
  /**
   * Actors / Tasks Identify the source of the finding, such as a tool, interviewed person, or activity
   * @type {Array<string>}
   * @memberof DomainObservation
   */
  originActors?: Array<string>;
  /**
   *
   * @type {Array<DomainProperty>}
   * @memberof DomainObservation
   */
  props?: Array<DomainProperty>;
  /**
   *
   * @type {Array<string>}
   * @memberof DomainObservation
   */
  relatedTasks?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof DomainObservation
   */
  remarks?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof DomainObservation
   */
  subjects?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof DomainObservation
   */
  title?: string;
  /**
   *
   * @type {Array<DomainObservationType>}
   * @memberof DomainObservation
   */
  types?: Array<DomainObservationType>;
}
/**
 *
 * @export
 * @enum {string}
 */

export const DomainObservationMethod = {
  ObservationMethodExamine: "examine",
  ObservationMethodInterview: "interview",
  ObservationMethodTest: "test",
  ObservationMethodUnknown: "unknown",
} as const;

export type DomainObservationMethod = (typeof DomainObservationMethod)[keyof typeof DomainObservationMethod];

/**
 *
 * @export
 * @enum {string}
 */

export const DomainObservationType = {
  ObservationTypeSSPStatementIssue: "ssp-statement-issue",
  ObservationTypeControlObjective: "control-objective",
  ObservationTypeMitigation: "mitigation",
  ObservationTypeFinding: "finding",
  ObservationTypeHistoric: "historic",
} as const;

export type DomainObservationType = (typeof DomainObservationType)[keyof typeof DomainObservationType];

/**
 *
 * @export
 * @enum {string}
 */

export const DomainOperationalStatus = {
  Disposition: 0,
  Operational: 1,
  Other: 2,
  UnderDevelopment: 3,
  UnderMajorModification: 4,
} as const;

export type DomainOperationalStatus = (typeof DomainOperationalStatus)[keyof typeof DomainOperationalStatus];

/**
 *
 * @export
 * @interface DomainProperty
 */
export interface DomainProperty {
  /**
   *
   * @type {string}
   * @memberof DomainProperty
   */
  class?: string;
  /**
   *
   * @type {string}
   * @memberof DomainProperty
   */
  group?: string;
  /**
   *
   * @type {string}
   * @memberof DomainProperty
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof DomainProperty
   */
  ns?: string;
  /**
   *
   * @type {string}
   * @memberof DomainProperty
   */
  remarks?: string;
  /**
   *
   * @type {string}
   * @memberof DomainProperty
   */
  value?: string;
}
/**
 *
 * @export
 * @interface DomainResource
 */
export interface DomainResource {
  /**
   *
   * @type {DomainBase64}
   * @memberof DomainResource
   */
  base64?: DomainBase64;
  /**
   *
   * @type {DomainCitation}
   * @memberof DomainResource
   */
  citation?: DomainCitation;
  /**
   * An optional short summary of the resource.
   * @type {string}
   * @memberof DomainResource
   */
  description?: string;
  /**
   * Document identifiers associated with the resource.
   * @type {Array<DomainDocumentIdentifier>}
   * @memberof DomainResource
   */
  "document-ids"?: Array<DomainDocumentIdentifier>;
  /**
   * Properties of the resource.
   * @type {Array<DomainProperty>}
   * @memberof DomainResource
   */
  props?: Array<DomainProperty>;
  /**
   * Remarks about the resource.
   * @type {string}
   * @memberof DomainResource
   */
  remarks?: string;
  /**
   * Related links of the resource.
   * @type {Array<DomainLink>}
   * @memberof DomainResource
   */
  rlinks?: Array<DomainLink>;
  /**
   * An optional name given to the resource.
   * @type {string}
   * @memberof DomainResource
   */
  title?: string;
  /**
   * A unique identifier for a resource.
   * @type {string}
   * @memberof DomainResource
   */
  uuid?: string;
}
/**
 *
 * @export
 * @interface DomainResponse
 */
export interface DomainResponse {
  /**
   *
   * @type {string}
   * @memberof DomainResponse
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof DomainResponse
   */
  id?: string;
  /**
   * Identifies whether this is a recommendation, such as from an assessor or tool, or an actual plan accepted by the system owner. One of: recommendation, planned, completed
   * @type {string}
   * @memberof DomainResponse
   */
  lifecycle?: string;
  /**
   *
   * @type {Array<DomainLink>}
   * @memberof DomainResponse
   */
  links?: Array<DomainLink>;
  /**
   * Actors / Tasks Identify the source of the finding, such as a tool, interviewed person, or activity
   * @type {Array<string>}
   * @memberof DomainResponse
   */
  originActors?: Array<string>;
  /**
   *
   * @type {Array<DomainProperty>}
   * @memberof DomainResponse
   */
  props?: Array<DomainProperty>;
  /**
   *
   * @type {Array<string>}
   * @memberof DomainResponse
   */
  relatedTasks?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof DomainResponse
   */
  title?: string;
}
/**
 *
 * @export
 * @interface DomainRevision
 */
export interface DomainRevision {
  /**
   *
   * @type {string}
   * @memberof DomainRevision
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof DomainRevision
   */
  lastModified?: string;
  /**
   *
   * @type {Array<DomainLink>}
   * @memberof DomainRevision
   */
  links?: Array<DomainLink>;
  /**
   *
   * @type {string}
   * @memberof DomainRevision
   */
  oscalVersion?: string;
  /**
   *
   * @type {Array<DomainProperty>}
   * @memberof DomainRevision
   */
  props?: Array<DomainProperty>;
  /**
   *
   * @type {string}
   * @memberof DomainRevision
   */
  published?: string;
  /**
   *
   * @type {string}
   * @memberof DomainRevision
   */
  remarks?: string;
  /**
   *
   * @type {string}
   * @memberof DomainRevision
   */
  title?: string;
  /**
   *
   * @type {string}
   * @memberof DomainRevision
   */
  version?: string;
}
/**
 *
 * @export
 * @interface DomainRisk
 */
export interface DomainRisk {
  /**
   *
   * @type {Array<DomainCharacterization>}
   * @memberof DomainRisk
   */
  characterizations?: Array<DomainCharacterization>;
  /**
   *
   * @type {string}
   * @memberof DomainRisk
   */
  deadline?: string;
  /**
   * A human-readable summary of the identified risk, to include a statement of how the risk impacts the system.
   * @type {string}
   * @memberof DomainRisk
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof DomainRisk
   */
  id?: string;
  /**
   *
   * @type {Array<DomainLink>}
   * @memberof DomainRisk
   */
  links?: Array<DomainLink>;
  /**
   *
   * @type {Array<string>}
   * @memberof DomainRisk
   */
  mitigatingFactors?: Array<string>;
  /**
   * Actors / Tasks Identify the source of the finding, such as a tool, interviewed person, or activity
   * @type {Array<string>}
   * @memberof DomainRisk
   */
  originActors?: Array<string>;
  /**
   *
   * @type {Array<DomainProperty>}
   * @memberof DomainRisk
   */
  props?: Array<DomainProperty>;
  /**
   *
   * @type {Array<string>}
   * @memberof DomainRisk
   */
  relatedObservations?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof DomainRisk
   */
  relatedTasks?: Array<string>;
  /**
   *
   * @type {Array<DomainResponse>}
   * @memberof DomainRisk
   */
  remediations?: Array<DomainResponse>;
  /**
   *
   * @type {Array<DomainRiskLogEntry>}
   * @memberof DomainRisk
   */
  riskLog?: Array<DomainRiskLogEntry>;
  /**
   * A summary of impact for how the risk affects the system.
   * @type {string}
   * @memberof DomainRisk
   */
  statement?: string;
  /**
   *
   * @type {DomainRiskStatus}
   * @memberof DomainRisk
   */
  status?: DomainRiskStatus;
  /**
   *
   * @type {Array<string>}
   * @memberof DomainRisk
   */
  threats?: Array<string>;
  /**
   * The title for this risk.
   * @type {string}
   * @memberof DomainRisk
   */
  title?: string;
}

/**
 *
 * @export
 * @interface DomainRiskLogEntry
 */
export interface DomainRiskLogEntry {
  /**
   *
   * @type {string}
   * @memberof DomainRiskLogEntry
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof DomainRiskLogEntry
   */
  end?: string;
  /**
   *
   * @type {string}
   * @memberof DomainRiskLogEntry
   */
  id?: string;
  /**
   *
   * @type {Array<DomainLink>}
   * @memberof DomainRiskLogEntry
   */
  links?: Array<DomainLink>;
  /**
   *
   * @type {DomainActor}
   * @memberof DomainRiskLogEntry
   */
  loggedBy?: DomainActor;
  /**
   *
   * @type {Array<DomainProperty>}
   * @memberof DomainRiskLogEntry
   */
  props?: Array<DomainProperty>;
  /**
   *
   * @type {string}
   * @memberof DomainRiskLogEntry
   */
  start?: string;
  /**
   *
   * @type {string}
   * @memberof DomainRiskLogEntry
   */
  title?: string;
}
/**
 *
 * @export
 * @enum {string}
 */

export const DomainRiskStatus = {
  RiskStatusOpen: "open",
  RiskStatusInvestigating: "investigating",
  RiskStatusRemediating: "remediating",
  RiskStatusDeviationRequested: "deviation-requested",
  RiskStatusDeviationApproved: "deviation-approved",
  RiskStatusClosed: "closed",
} as const;

export type DomainRiskStatus = (typeof DomainRiskStatus)[keyof typeof DomainRiskStatus];

/**
 *
 * @export
 * @interface DomainSecurityImpactLevel
 */
export interface DomainSecurityImpactLevel {
  /**
   *
   * @type {string}
   * @memberof DomainSecurityImpactLevel
   */
  objective_availability?: string;
  /**
   *
   * @type {string}
   * @memberof DomainSecurityImpactLevel
   */
  objective_confidentiality?: string;
  /**
   *
   * @type {string}
   * @memberof DomainSecurityImpactLevel
   */
  objective_integrity?: string;
}
/**
 *
 * @export
 * @interface DomainSystemCharacteristics
 */
export interface DomainSystemCharacteristics {
  /**
   *
   * @type {Array<DomainAction>}
   * @memberof DomainSystemCharacteristics
   */
  actions?: Array<DomainAction>;
  /**
   *
   * @type {DomainAuthorizationBoundary}
   * @memberof DomainSystemCharacteristics
   */
  authorization_boundary?: DomainAuthorizationBoundary;
  /**
   *
   * @type {Array<string>}
   * @memberof DomainSystemCharacteristics
   */
  control_implementation?: Array<string>;
  /**
   *
   * @type {DomainDataFlow}
   * @memberof DomainSystemCharacteristics
   */
  data_flow?: DomainDataFlow;
  /**
   *
   * @type {string}
   * @memberof DomainSystemCharacteristics
   */
  date_authorized?: string;
  /**
   *
   * @type {string}
   * @memberof DomainSystemCharacteristics
   */
  description?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof DomainSystemCharacteristics
   */
  import_profile?: Array<string>;
  /**
   *
   * @type {Array<DomainLink>}
   * @memberof DomainSystemCharacteristics
   */
  links?: Array<DomainLink>;
  /**
   *
   * @type {DomainNetworkArchitecture}
   * @memberof DomainSystemCharacteristics
   */
  network_architecture?: DomainNetworkArchitecture;
  /**
   *
   * @type {Array<string>}
   * @memberof DomainSystemCharacteristics
   */
  partyUuids?: Array<string>;
  /**
   *
   * @type {Array<DomainProperty>}
   * @memberof DomainSystemCharacteristics
   */
  props?: Array<DomainProperty>;
  /**
   *
   * @type {string}
   * @memberof DomainSystemCharacteristics
   */
  remarks?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof DomainSystemCharacteristics
   */
  responsiblePartyUuids?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof DomainSystemCharacteristics
   */
  responsible_parties?: Array<string>;
  /**
   *
   * @type {Array<DomainRevision>}
   * @memberof DomainSystemCharacteristics
   */
  revisions?: Array<DomainRevision>;
  /**
   *
   * @type {Array<string>}
   * @memberof DomainSystemCharacteristics
   */
  roleUuids?: Array<string>;
  /**
   *
   * @type {DomainSecurityImpactLevel}
   * @memberof DomainSystemCharacteristics
   */
  security_impact_level?: DomainSecurityImpactLevel;
  /**
   * The overall information system sensitivity categorization, such as defined by FIPS-199.
   * @type {string}
   * @memberof DomainSystemCharacteristics
   */
  security_sensitivity_level?: string;
  /**
   *
   * @type {DomainOperationalStatus}
   * @memberof DomainSystemCharacteristics
   */
  status?: DomainOperationalStatus;
  /**
   * One of http://fedramp.gov/ns/oscal, https://fedramp.gov\", http://ietf.org/rfc/rfc4122\", https://ietf.org/rfc/rfc4122
   * @type {Array<string>}
   * @memberof DomainSystemCharacteristics
   */
  system_ids?: Array<string>;
  /**
   *
   * @type {DomainSystemInformation}
   * @memberof DomainSystemCharacteristics
   */
  system_information?: DomainSystemInformation;
  /**
   * The full name of the system.
   * @type {string}
   * @memberof DomainSystemCharacteristics
   */
  system_name?: string;
  /**
   * A short name for the system, such as an acronym, that is suitable for display in a data table or summary list.
   * @type {string}
   * @memberof DomainSystemCharacteristics
   */
  system_name_short?: string;
  /**
   *
   * @type {string}
   * @memberof DomainSystemCharacteristics
   */
  title?: string;
  /**
   *
   * @type {string}
   * @memberof DomainSystemCharacteristics
   */
  uuid?: string;
}

/**
 *
 * @export
 * @interface DomainSystemInformation
 */
export interface DomainSystemInformation {
  /**
   * Contains details about one information type that is stored, processed, or transmitted by the system, such as privacy information, and those defined in NIST SP 800-60.
   * @type {Array<DomainInformationType>}
   * @memberof DomainSystemInformation
   */
  information_types?: Array<DomainInformationType>;
  /**
   *
   * @type {Array<DomainLink>}
   * @memberof DomainSystemInformation
   */
  links?: Array<DomainLink>;
  /**
   *
   * @type {Array<DomainProperty>}
   * @memberof DomainSystemInformation
   */
  props?: Array<DomainProperty>;
  /**
   *
   * @type {string}
   * @memberof DomainSystemInformation
   */
  uuid?: string;
}
/**
 *
 * @export
 * @interface DomainSystemSecurityPlan
 */
export interface DomainSystemSecurityPlan {
  /**
   *
   * @type {Array<DomainAction>}
   * @memberof DomainSystemSecurityPlan
   */
  actions?: Array<DomainAction>;
  /**
   *
   * @type {DomainBackMatter}
   * @memberof DomainSystemSecurityPlan
   */
  backmatter?: DomainBackMatter;
  /**
   * Reference to the control implementation
   * @type {Array<string>}
   * @memberof DomainSystemSecurityPlan
   */
  control_implementation?: Array<string>;
  /**
   * Reference to a profile
   * @type {string}
   * @memberof DomainSystemSecurityPlan
   */
  import_profile?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof DomainSystemSecurityPlan
   */
  partyUuids?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof DomainSystemSecurityPlan
   */
  responsiblePartyUuids?: Array<string>;
  /**
   *
   * @type {Array<DomainRevision>}
   * @memberof DomainSystemSecurityPlan
   */
  revisions?: Array<DomainRevision>;
  /**
   *
   * @type {Array<string>}
   * @memberof DomainSystemSecurityPlan
   */
  roleUuids?: Array<string>;
  /**
   *
   * @type {DomainSystemCharacteristics}
   * @memberof DomainSystemSecurityPlan
   */
  system_characteristics?: DomainSystemCharacteristics;
  /**
   *
   * @type {string}
   * @memberof DomainSystemSecurityPlan
   */
  title?: string;
  /**
   *
   * @type {string}
   * @memberof DomainSystemSecurityPlan
   */
  uuid?: string;
}
/**
 *
 * @export
 * @interface HandlerAttachMetadataRequest
 */
export interface HandlerAttachMetadataRequest {
  /**
   *
   * @type {string}
   * @memberof HandlerAttachMetadataRequest
   */
  collection: string;
  /**
   *
   * @type {string}
   * @memberof HandlerAttachMetadataRequest
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof HandlerAttachMetadataRequest
   */
  revisionDescription?: string;
  /**
   *
   * @type {string}
   * @memberof HandlerAttachMetadataRequest
   */
  revisionRemarks?: string;
  /**
   *
   * @type {string}
   * @memberof HandlerAttachMetadataRequest
   */
  revisionTitle?: string;
}
/**
 *
 * @export
 * @interface HandlerCatalogIdResponse
 */
export interface HandlerCatalogIdResponse {
  /**
   * The unique identifier of the catalog. Required: true Example: \"123abc\"
   * @type {string}
   * @memberof HandlerCatalogIdResponse
   */
  id?: string;
}
/**
 *
 * @export
 * @interface HandlerCreateActivityRequest
 */
export interface HandlerCreateActivityRequest {
  /**
   *
   * @type {string}
   * @memberof HandlerCreateActivityRequest
   */
  description?: string;
  /**
   *
   * @type {HandlerCreateActivityRequestProvider}
   * @memberof HandlerCreateActivityRequest
   */
  provider: HandlerCreateActivityRequestProvider;
  /**
   *
   * @type {HandlerCreateActivityRequestSubjects}
   * @memberof HandlerCreateActivityRequest
   */
  subjects?: HandlerCreateActivityRequestSubjects;
  /**
   *
   * @type {string}
   * @memberof HandlerCreateActivityRequest
   */
  title: string;
}
/**
 *
 * @export
 * @interface HandlerCreateActivityRequestProvider
 */
export interface HandlerCreateActivityRequestProvider {
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof HandlerCreateActivityRequestProvider
   */
  configuration?: { [key: string]: string };
  /**
   *
   * @type {string}
   * @memberof HandlerCreateActivityRequestProvider
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof HandlerCreateActivityRequestProvider
   */
  package: string;
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof HandlerCreateActivityRequestProvider
   */
  params?: { [key: string]: string };
  /**
   *
   * @type {string}
   * @memberof HandlerCreateActivityRequestProvider
   */
  version: string;
}
/**
 *
 * @export
 * @interface HandlerCreateActivityRequestSubjects
 */
export interface HandlerCreateActivityRequestSubjects {
  /**
   *
   * @type {string}
   * @memberof HandlerCreateActivityRequestSubjects
   */
  description: string;
  /**
   *
   * @type {Array<HandlerCreateActivityRequestSubjectsExpressionsInner>}
   * @memberof HandlerCreateActivityRequestSubjects
   */
  expressions?: Array<HandlerCreateActivityRequestSubjectsExpressionsInner>;
  /**
   *
   * @type {Array<string>}
   * @memberof HandlerCreateActivityRequestSubjects
   */
  ids?: Array<string>;
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof HandlerCreateActivityRequestSubjects
   */
  labels?: { [key: string]: string };
  /**
   *
   * @type {string}
   * @memberof HandlerCreateActivityRequestSubjects
   */
  query?: string;
  /**
   *
   * @type {string}
   * @memberof HandlerCreateActivityRequestSubjects
   */
  title: string;
}
/**
 *
 * @export
 * @interface HandlerCreateActivityRequestSubjectsExpressionsInner
 */
export interface HandlerCreateActivityRequestSubjectsExpressionsInner {
  /**
   *
   * @type {string}
   * @memberof HandlerCreateActivityRequestSubjectsExpressionsInner
   */
  key?: string;
  /**
   *
   * @type {string}
   * @memberof HandlerCreateActivityRequestSubjectsExpressionsInner
   */
  operator?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof HandlerCreateActivityRequestSubjectsExpressionsInner
   */
  values?: Array<string>;
}
/**
 *
 * @export
 * @interface HandlerCreateCatalogRequest
 */
export interface HandlerCreateCatalogRequest {
  /**
   *
   * @type {HandlerCreateCatalogRequestCatalog}
   * @memberof HandlerCreateCatalogRequest
   */
  catalog?: HandlerCreateCatalogRequestCatalog;
}
/**
 *
 * @export
 * @interface HandlerCreateCatalogRequestCatalog
 */
export interface HandlerCreateCatalogRequestCatalog {
  /**
   *
   * @type {string}
   * @memberof HandlerCreateCatalogRequestCatalog
   */
  title: string;
}
/**
 *
 * @export
 * @interface HandlerCreatePlanRequest
 */
export interface HandlerCreatePlanRequest {
  /**
   *
   * @type {string}
   * @memberof HandlerCreatePlanRequest
   */
  title: string;
}
/**
 *
 * @export
 * @interface HandlerCreateSSPRequest
 */
export interface HandlerCreateSSPRequest {
  /**
   *
   * @type {string}
   * @memberof HandlerCreateSSPRequest
   */
  title: string;
}
/**
 *
 * @export
 * @interface HandlerCreateTaskRequest
 */
export interface HandlerCreateTaskRequest {
  /**
   *
   * @type {string}
   * @memberof HandlerCreateTaskRequest
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof HandlerCreateTaskRequest
   */
  schedule: string;
  /**
   * TODO: We are keeping it minimal for now for the demo
   * @type {string}
   * @memberof HandlerCreateTaskRequest
   */
  title: string;
  /**
   *
   * @type {string}
   * @memberof HandlerCreateTaskRequest
   */
  type: string;
}
/**
 *
 * @export
 * @interface HandlerIdResponse
 */
export interface HandlerIdResponse {
  /**
   * The unique identifier of the plan. Required: true Example: \"456def\"
   * @type {string}
   * @memberof HandlerIdResponse
   */
  id?: string;
}
/**
 *
 * @export
 * @interface HandlerUpdateSSPRequest
 */
export interface HandlerUpdateSSPRequest {
  /**
   *
   * @type {string}
   * @memberof HandlerUpdateSSPRequest
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof HandlerUpdateSSPRequest
   */
  title?: string;
}
/**
 *
 * @export
 * @interface ServiceComplianceStatusByTargets
 */
export interface ServiceComplianceStatusByTargets {
  /**
   *
   * @type {Array<ServiceRiskState>}
   * @memberof ServiceComplianceStatusByTargets
   */
  compliance?: Array<ServiceRiskState>;
  /**
   *
   * @type {string}
   * @memberof ServiceComplianceStatusByTargets
   */
  control?: string;
  /**
   *
   * @type {string}
   * @memberof ServiceComplianceStatusByTargets
   */
  target?: string;
}
/**
 *
 * @export
 * @interface ServiceComplianceStatusOverTime
 */
export interface ServiceComplianceStatusOverTime {
  /**
   *
   * @type {string}
   * @memberof ServiceComplianceStatusOverTime
   */
  date?: string;
  /**
   *
   * @type {number}
   * @memberof ServiceComplianceStatusOverTime
   */
  findings?: number;
  /**
   *
   * @type {number}
   * @memberof ServiceComplianceStatusOverTime
   */
  observations?: number;
  /**
   *
   * @type {number}
   * @memberof ServiceComplianceStatusOverTime
   */
  risks?: number;
}
/**
 *
 * @export
 * @interface ServicePlanSummary
 */
export interface ServicePlanSummary {
  /**
   *
   * @type {number}
   * @memberof ServicePlanSummary
   */
  complianceStatus?: number;
  /**
   *
   * @type {string}
   * @memberof ServicePlanSummary
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof ServicePlanSummary
   */
  endDate?: string;
  /**
   *
   * @type {number}
   * @memberof ServicePlanSummary
   */
  numControls?: number;
  /**
   *
   * @type {number}
   * @memberof ServicePlanSummary
   */
  numObservations?: number;
  /**
   *
   * @type {number}
   * @memberof ServicePlanSummary
   */
  numRisks?: number;
  /**
   *
   * @type {number}
   * @memberof ServicePlanSummary
   */
  numSubjects?: number;
  /**
   *
   * @type {string}
   * @memberof ServicePlanSummary
   */
  published?: string;
  /**
   *
   * @type {ServiceRiskLevels}
   * @memberof ServicePlanSummary
   */
  riskLevels?: ServiceRiskLevels;
  /**
   *
   * @type {ServiceRiskScore}
   * @memberof ServicePlanSummary
   */
  riskScore?: ServiceRiskScore;
  /**
   *
   * @type {string}
   * @memberof ServicePlanSummary
   */
  status?: string;
}
/**
 *
 * @export
 * @interface ServiceRemediationVsTime
 */
export interface ServiceRemediationVsTime {
  /**
   *
   * @type {string}
   * @memberof ServiceRemediationVsTime
   */
  control?: string;
  /**
   *
   * @type {string}
   * @memberof ServiceRemediationVsTime
   */
  remediation?: string;
}
/**
 *
 * @export
 * @interface ServiceRiskLevels
 */
export interface ServiceRiskLevels {
  /**
   *
   * @type {number}
   * @memberof ServiceRiskLevels
   */
  high?: number;
  /**
   *
   * @type {number}
   * @memberof ServiceRiskLevels
   */
  low?: number;
  /**
   *
   * @type {number}
   * @memberof ServiceRiskLevels
   */
  medium?: number;
}
/**
 *
 * @export
 * @interface ServiceRiskScore
 */
export interface ServiceRiskScore {
  /**
   *
   * @type {number}
   * @memberof ServiceRiskScore
   */
  score?: number;
  /**
   *
   * @type {ServiceRiskSeverity}
   * @memberof ServiceRiskScore
   */
  severity?: ServiceRiskSeverity;
}

/**
 *
 * @export
 * @enum {string}
 */

export const ServiceRiskSeverity = {
  Medium: "medium",
  Low: "low",
  High: "high",
} as const;

export type ServiceRiskSeverity = (typeof ServiceRiskSeverity)[keyof typeof ServiceRiskSeverity];

/**
 *
 * @export
 * @enum {string}
 */

export const ServiceRiskState = {
  Pass: "pass",
  Warn: "warn",
  Fail: "fail",
  Indeterminate: "indeterminate",
} as const;

export type ServiceRiskState = (typeof ServiceRiskState)[keyof typeof ServiceRiskState];

/**
 * CatalogApi - axios parameter creator
 * @export
 */
export const CatalogApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Create a catalog with the given title
     * @summary Create a catalog
     * @param {HandlerCreateCatalogRequest} handlerCreateCatalogRequest Catalog to add
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    catalogPost: async (
      handlerCreateCatalogRequest: HandlerCreateCatalogRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'handlerCreateCatalogRequest' is not null or undefined
      assertParamExists("catalogPost", "handlerCreateCatalogRequest", handlerCreateCatalogRequest);
      const localVarPath = `/catalog`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        handlerCreateCatalogRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * CatalogApi - functional programming interface
 * @export
 */
export const CatalogApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = CatalogApiAxiosParamCreator(configuration);
  return {
    /**
     * Create a catalog with the given title
     * @summary Create a catalog
     * @param {HandlerCreateCatalogRequest} handlerCreateCatalogRequest Catalog to add
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async catalogPost(
      handlerCreateCatalogRequest: HandlerCreateCatalogRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HandlerCatalogIdResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.catalogPost(handlerCreateCatalogRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * CatalogApi - factory interface
 * @export
 */
export const CatalogApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = CatalogApiFp(configuration);
  return {
    /**
     * Create a catalog with the given title
     * @summary Create a catalog
     * @param {HandlerCreateCatalogRequest} handlerCreateCatalogRequest Catalog to add
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    catalogPost(
      handlerCreateCatalogRequest: HandlerCreateCatalogRequest,
      options?: any,
    ): AxiosPromise<HandlerCatalogIdResponse> {
      return localVarFp.catalogPost(handlerCreateCatalogRequest, options).then(request => request(axios, basePath));
    },
  };
};

/**
 * CatalogApi - object-oriented interface
 * @export
 * @class CatalogApi
 * @extends {BaseAPI}
 */
export class CatalogApi extends BaseAPI {
  /**
   * Create a catalog with the given title
   * @summary Create a catalog
   * @param {HandlerCreateCatalogRequest} handlerCreateCatalogRequest Catalog to add
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CatalogApi
   */
  public catalogPost(handlerCreateCatalogRequest: HandlerCreateCatalogRequest, options?: AxiosRequestConfig) {
    return CatalogApiFp(this.configuration)
      .catalogPost(handlerCreateCatalogRequest, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * MetadataApi - axios parameter creator
 * @export
 */
export const MetadataApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * This method attaches metadata to a specific revision.
     * @summary Attaches metadata to a specific revision
     * @param {HandlerAttachMetadataRequest} handlerAttachMetadataRequest Revision that will be attached
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    metadataRevisionsPost: async (
      handlerAttachMetadataRequest: HandlerAttachMetadataRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'handlerAttachMetadataRequest' is not null or undefined
      assertParamExists("metadataRevisionsPost", "handlerAttachMetadataRequest", handlerAttachMetadataRequest);
      const localVarPath = `/metadata/revisions`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        handlerAttachMetadataRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * MetadataApi - functional programming interface
 * @export
 */
export const MetadataApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = MetadataApiAxiosParamCreator(configuration);
  return {
    /**
     * This method attaches metadata to a specific revision.
     * @summary Attaches metadata to a specific revision
     * @param {HandlerAttachMetadataRequest} handlerAttachMetadataRequest Revision that will be attached
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async metadataRevisionsPost(
      handlerAttachMetadataRequest: HandlerAttachMetadataRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.metadataRevisionsPost(
        handlerAttachMetadataRequest,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * MetadataApi - factory interface
 * @export
 */
export const MetadataApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = MetadataApiFp(configuration);
  return {
    /**
     * This method attaches metadata to a specific revision.
     * @summary Attaches metadata to a specific revision
     * @param {HandlerAttachMetadataRequest} handlerAttachMetadataRequest Revision that will be attached
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    metadataRevisionsPost(
      handlerAttachMetadataRequest: HandlerAttachMetadataRequest,
      options?: any,
    ): AxiosPromise<string> {
      return localVarFp
        .metadataRevisionsPost(handlerAttachMetadataRequest, options)
        .then(request => request(axios, basePath));
    },
  };
};

/**
 * MetadataApi - object-oriented interface
 * @export
 * @class MetadataApi
 * @extends {BaseAPI}
 */
export class MetadataApi extends BaseAPI {
  /**
   * This method attaches metadata to a specific revision.
   * @summary Attaches metadata to a specific revision
   * @param {HandlerAttachMetadataRequest} handlerAttachMetadataRequest Revision that will be attached
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MetadataApi
   */
  public metadataRevisionsPost(
    handlerAttachMetadataRequest: HandlerAttachMetadataRequest,
    options?: AxiosRequestConfig,
  ) {
    return MetadataApiFp(this.configuration)
      .metadataRevisionsPost(handlerAttachMetadataRequest, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * PlanApi - axios parameter creator
 * @export
 */
export const PlanApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Activate a plan by its ID. If the plan is already active, no action will be taken.
     * @summary Activate a plan
     * @param {string} id Plan ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    planIdActivatePut: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("planIdActivatePut", "id", id);
      const localVarPath = `/plan/{id}/activate`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Return the compliance over time of the result with the given ID.
     * @summary Return the compliance over time
     * @param {string} id Plan ID
     * @param {string} resultId Result ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    planIdResultsResultIdComplianceOverTimeGet: async (
      id: string,
      resultId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("planIdResultsResultIdComplianceOverTimeGet", "id", id);
      // verify required parameter 'resultId' is not null or undefined
      assertParamExists("planIdResultsResultIdComplianceOverTimeGet", "resultId", resultId);
      const localVarPath = `/plan/{id}/results/{resultId}/compliance-over-time`
        .replace(`{${"id"}}`, encodeURIComponent(String(id)))
        .replace(`{${"resultId"}}`, encodeURIComponent(String(resultId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Return the compliance status by targets of the result with the given ID.
     * @summary Return the compliance status by targets
     * @param {string} id Plan ID
     * @param {string} resultId Result ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    planIdResultsResultIdComplianceStatusByTargetsGet: async (
      id: string,
      resultId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("planIdResultsResultIdComplianceStatusByTargetsGet", "id", id);
      // verify required parameter 'resultId' is not null or undefined
      assertParamExists("planIdResultsResultIdComplianceStatusByTargetsGet", "resultId", resultId);
      const localVarPath = `/plan/{id}/results/{resultId}/compliance-status-by-targets`
        .replace(`{${"id"}}`, encodeURIComponent(String(id)))
        .replace(`{${"resultId"}}`, encodeURIComponent(String(resultId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Return the findings of the result with the given ID.
     * @summary Return the findings
     * @param {string} id Plan ID
     * @param {string} resultId Result ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    planIdResultsResultIdFindingsGet: async (
      id: string,
      resultId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("planIdResultsResultIdFindingsGet", "id", id);
      // verify required parameter 'resultId' is not null or undefined
      assertParamExists("planIdResultsResultIdFindingsGet", "resultId", resultId);
      const localVarPath = `/plan/{id}/results/{resultId}/findings`
        .replace(`{${"id"}}`, encodeURIComponent(String(id)))
        .replace(`{${"resultId"}}`, encodeURIComponent(String(resultId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Return the observations of the result with the given ID.
     * @summary Return the observations
     * @param {string} id Plan ID
     * @param {string} resultId Result ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    planIdResultsResultIdObservationsGet: async (
      id: string,
      resultId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("planIdResultsResultIdObservationsGet", "id", id);
      // verify required parameter 'resultId' is not null or undefined
      assertParamExists("planIdResultsResultIdObservationsGet", "resultId", resultId);
      const localVarPath = `/plan/{id}/results/{resultId}/observations`
        .replace(`{${"id"}}`, encodeURIComponent(String(id)))
        .replace(`{${"resultId"}}`, encodeURIComponent(String(resultId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Return the remediation versus time of the result with the given ID.
     * @summary Return the remediation versus time
     * @param {string} id Plan ID
     * @param {string} resultId Result ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    planIdResultsResultIdRemediationVsTimeGet: async (
      id: string,
      resultId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("planIdResultsResultIdRemediationVsTimeGet", "id", id);
      // verify required parameter 'resultId' is not null or undefined
      assertParamExists("planIdResultsResultIdRemediationVsTimeGet", "resultId", resultId);
      const localVarPath = `/plan/{id}/results/{resultId}/remediation-vs-time`
        .replace(`{${"id"}}`, encodeURIComponent(String(id)))
        .replace(`{${"resultId"}}`, encodeURIComponent(String(resultId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Return the risks of the result with the given ID.
     * @summary Return the risks
     * @param {string} id Plan ID
     * @param {string} resultId Result ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    planIdResultsResultIdRisksGet: async (
      id: string,
      resultId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("planIdResultsResultIdRisksGet", "id", id);
      // verify required parameter 'resultId' is not null or undefined
      assertParamExists("planIdResultsResultIdRisksGet", "resultId", resultId);
      const localVarPath = `/plan/{id}/results/{resultId}/risks`
        .replace(`{${"id"}}`, encodeURIComponent(String(id)))
        .replace(`{${"resultId"}}`, encodeURIComponent(String(resultId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Return the summary of the result with the given ID.
     * @summary Return the result summary
     * @param {string} id Plan ID
     * @param {string} resultId Result ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    planIdResultsResultIdSummaryGet: async (
      id: string,
      resultId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("planIdResultsResultIdSummaryGet", "id", id);
      // verify required parameter 'resultId' is not null or undefined
      assertParamExists("planIdResultsResultIdSummaryGet", "resultId", resultId);
      const localVarPath = `/plan/{id}/results/{resultId}/summary`
        .replace(`{${"id"}}`, encodeURIComponent(String(id)))
        .replace(`{${"resultId"}}`, encodeURIComponent(String(resultId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This method creates a new task and adds it to a specific plan.
     * @summary Creates a new task for a specific plan
     * @param {string} id Plan ID
     * @param {HandlerCreateTaskRequest} handlerCreateTaskRequest Task to add
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    planIdTasksPost: async (
      id: string,
      handlerCreateTaskRequest: HandlerCreateTaskRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("planIdTasksPost", "id", id);
      // verify required parameter 'handlerCreateTaskRequest' is not null or undefined
      assertParamExists("planIdTasksPost", "handlerCreateTaskRequest", handlerCreateTaskRequest);
      const localVarPath = `/plan/{id}/tasks`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        handlerCreateTaskRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This function is used to create an activity for a given task.
     * @summary Create activity
     * @param {number} id Plan ID
     * @param {number} taskId Task ID
     * @param {HandlerCreateActivityRequest} handlerCreateActivityRequest Activity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    planIdTasksTaskIdActivitiesPost: async (
      id: number,
      taskId: number,
      handlerCreateActivityRequest: HandlerCreateActivityRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("planIdTasksTaskIdActivitiesPost", "id", id);
      // verify required parameter 'taskId' is not null or undefined
      assertParamExists("planIdTasksTaskIdActivitiesPost", "taskId", taskId);
      // verify required parameter 'handlerCreateActivityRequest' is not null or undefined
      assertParamExists(
        "planIdTasksTaskIdActivitiesPost",
        "handlerCreateActivityRequest",
        handlerCreateActivityRequest,
      );
      const localVarPath = `/plan/{id}/tasks/{taskId}/activities`
        .replace(`{${"id"}}`, encodeURIComponent(String(id)))
        .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        handlerCreateActivityRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Creates a new plan in the system
     * @summary Create a plan
     * @param {HandlerCreatePlanRequest} handlerCreatePlanRequest Plan to add
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    planPost: async (
      handlerCreatePlanRequest: HandlerCreatePlanRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'handlerCreatePlanRequest' is not null or undefined
      assertParamExists("planPost", "handlerCreatePlanRequest", handlerCreatePlanRequest);
      const localVarPath = `/plan`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        handlerCreatePlanRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * PlanApi - functional programming interface
 * @export
 */
export const PlanApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = PlanApiAxiosParamCreator(configuration);
  return {
    /**
     * Activate a plan by its ID. If the plan is already active, no action will be taken.
     * @summary Activate a plan
     * @param {string} id Plan ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async planIdActivatePut(
      id: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.planIdActivatePut(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Return the compliance over time of the result with the given ID.
     * @summary Return the compliance over time
     * @param {string} id Plan ID
     * @param {string} resultId Result ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async planIdResultsResultIdComplianceOverTimeGet(
      id: string,
      resultId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ServiceComplianceStatusOverTime>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.planIdResultsResultIdComplianceOverTimeGet(
        id,
        resultId,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Return the compliance status by targets of the result with the given ID.
     * @summary Return the compliance status by targets
     * @param {string} id Plan ID
     * @param {string} resultId Result ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async planIdResultsResultIdComplianceStatusByTargetsGet(
      id: string,
      resultId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ServiceComplianceStatusByTargets>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.planIdResultsResultIdComplianceStatusByTargetsGet(
        id,
        resultId,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Return the findings of the result with the given ID.
     * @summary Return the findings
     * @param {string} id Plan ID
     * @param {string} resultId Result ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async planIdResultsResultIdFindingsGet(
      id: string,
      resultId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DomainFinding>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.planIdResultsResultIdFindingsGet(id, resultId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Return the observations of the result with the given ID.
     * @summary Return the observations
     * @param {string} id Plan ID
     * @param {string} resultId Result ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async planIdResultsResultIdObservationsGet(
      id: string,
      resultId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DomainObservation>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.planIdResultsResultIdObservationsGet(
        id,
        resultId,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Return the remediation versus time of the result with the given ID.
     * @summary Return the remediation versus time
     * @param {string} id Plan ID
     * @param {string} resultId Result ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async planIdResultsResultIdRemediationVsTimeGet(
      id: string,
      resultId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ServiceRemediationVsTime>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.planIdResultsResultIdRemediationVsTimeGet(
        id,
        resultId,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Return the risks of the result with the given ID.
     * @summary Return the risks
     * @param {string} id Plan ID
     * @param {string} resultId Result ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async planIdResultsResultIdRisksGet(
      id: string,
      resultId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DomainRisk>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.planIdResultsResultIdRisksGet(id, resultId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Return the summary of the result with the given ID.
     * @summary Return the result summary
     * @param {string} id Plan ID
     * @param {string} resultId Result ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async planIdResultsResultIdSummaryGet(
      id: string,
      resultId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServicePlanSummary>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.planIdResultsResultIdSummaryGet(id, resultId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * This method creates a new task and adds it to a specific plan.
     * @summary Creates a new task for a specific plan
     * @param {string} id Plan ID
     * @param {HandlerCreateTaskRequest} handlerCreateTaskRequest Task to add
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async planIdTasksPost(
      id: string,
      handlerCreateTaskRequest: HandlerCreateTaskRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.planIdTasksPost(id, handlerCreateTaskRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * This function is used to create an activity for a given task.
     * @summary Create activity
     * @param {number} id Plan ID
     * @param {number} taskId Task ID
     * @param {HandlerCreateActivityRequest} handlerCreateActivityRequest Activity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async planIdTasksTaskIdActivitiesPost(
      id: number,
      taskId: number,
      handlerCreateActivityRequest: HandlerCreateActivityRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HandlerIdResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.planIdTasksTaskIdActivitiesPost(
        id,
        taskId,
        handlerCreateActivityRequest,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Creates a new plan in the system
     * @summary Create a plan
     * @param {HandlerCreatePlanRequest} handlerCreatePlanRequest Plan to add
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async planPost(
      handlerCreatePlanRequest: HandlerCreatePlanRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HandlerIdResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.planPost(handlerCreatePlanRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * PlanApi - factory interface
 * @export
 */
export const PlanApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = PlanApiFp(configuration);
  return {
    /**
     * Activate a plan by its ID. If the plan is already active, no action will be taken.
     * @summary Activate a plan
     * @param {string} id Plan ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    planIdActivatePut(id: string, options?: any): AxiosPromise<void> {
      return localVarFp.planIdActivatePut(id, options).then(request => request(axios, basePath));
    },
    /**
     * Return the compliance over time of the result with the given ID.
     * @summary Return the compliance over time
     * @param {string} id Plan ID
     * @param {string} resultId Result ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    planIdResultsResultIdComplianceOverTimeGet(
      id: string,
      resultId: string,
      options?: any,
    ): AxiosPromise<Array<ServiceComplianceStatusOverTime>> {
      return localVarFp
        .planIdResultsResultIdComplianceOverTimeGet(id, resultId, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Return the compliance status by targets of the result with the given ID.
     * @summary Return the compliance status by targets
     * @param {string} id Plan ID
     * @param {string} resultId Result ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    planIdResultsResultIdComplianceStatusByTargetsGet(
      id: string,
      resultId: string,
      options?: any,
    ): AxiosPromise<Array<ServiceComplianceStatusByTargets>> {
      return localVarFp
        .planIdResultsResultIdComplianceStatusByTargetsGet(id, resultId, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Return the findings of the result with the given ID.
     * @summary Return the findings
     * @param {string} id Plan ID
     * @param {string} resultId Result ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    planIdResultsResultIdFindingsGet(id: string, resultId: string, options?: any): AxiosPromise<Array<DomainFinding>> {
      return localVarFp
        .planIdResultsResultIdFindingsGet(id, resultId, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Return the observations of the result with the given ID.
     * @summary Return the observations
     * @param {string} id Plan ID
     * @param {string} resultId Result ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    planIdResultsResultIdObservationsGet(
      id: string,
      resultId: string,
      options?: any,
    ): AxiosPromise<Array<DomainObservation>> {
      return localVarFp
        .planIdResultsResultIdObservationsGet(id, resultId, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Return the remediation versus time of the result with the given ID.
     * @summary Return the remediation versus time
     * @param {string} id Plan ID
     * @param {string} resultId Result ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    planIdResultsResultIdRemediationVsTimeGet(
      id: string,
      resultId: string,
      options?: any,
    ): AxiosPromise<Array<ServiceRemediationVsTime>> {
      return localVarFp
        .planIdResultsResultIdRemediationVsTimeGet(id, resultId, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Return the risks of the result with the given ID.
     * @summary Return the risks
     * @param {string} id Plan ID
     * @param {string} resultId Result ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    planIdResultsResultIdRisksGet(id: string, resultId: string, options?: any): AxiosPromise<Array<DomainRisk>> {
      return localVarFp.planIdResultsResultIdRisksGet(id, resultId, options).then(request => request(axios, basePath));
    },
    /**
     * Return the summary of the result with the given ID.
     * @summary Return the result summary
     * @param {string} id Plan ID
     * @param {string} resultId Result ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    planIdResultsResultIdSummaryGet(id: string, resultId: string, options?: any): AxiosPromise<ServicePlanSummary> {
      return localVarFp
        .planIdResultsResultIdSummaryGet(id, resultId, options)
        .then(request => request(axios, basePath));
    },
    /**
     * This method creates a new task and adds it to a specific plan.
     * @summary Creates a new task for a specific plan
     * @param {string} id Plan ID
     * @param {HandlerCreateTaskRequest} handlerCreateTaskRequest Task to add
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    planIdTasksPost(
      id: string,
      handlerCreateTaskRequest: HandlerCreateTaskRequest,
      options?: any,
    ): AxiosPromise<string> {
      return localVarFp
        .planIdTasksPost(id, handlerCreateTaskRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     * This function is used to create an activity for a given task.
     * @summary Create activity
     * @param {number} id Plan ID
     * @param {number} taskId Task ID
     * @param {HandlerCreateActivityRequest} handlerCreateActivityRequest Activity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    planIdTasksTaskIdActivitiesPost(
      id: number,
      taskId: number,
      handlerCreateActivityRequest: HandlerCreateActivityRequest,
      options?: any,
    ): AxiosPromise<HandlerIdResponse> {
      return localVarFp
        .planIdTasksTaskIdActivitiesPost(id, taskId, handlerCreateActivityRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Creates a new plan in the system
     * @summary Create a plan
     * @param {HandlerCreatePlanRequest} handlerCreatePlanRequest Plan to add
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    planPost(handlerCreatePlanRequest: HandlerCreatePlanRequest, options?: any): AxiosPromise<HandlerIdResponse> {
      return localVarFp.planPost(handlerCreatePlanRequest, options).then(request => request(axios, basePath));
    },
  };
};

/**
 * PlanApi - object-oriented interface
 * @export
 * @class PlanApi
 * @extends {BaseAPI}
 */
export class PlanApi extends BaseAPI {
  /**
   * Activate a plan by its ID. If the plan is already active, no action will be taken.
   * @summary Activate a plan
   * @param {string} id Plan ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PlanApi
   */
  public planIdActivatePut(id: string, options?: AxiosRequestConfig) {
    return PlanApiFp(this.configuration)
      .planIdActivatePut(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Return the compliance over time of the result with the given ID.
   * @summary Return the compliance over time
   * @param {string} id Plan ID
   * @param {string} resultId Result ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PlanApi
   */
  public planIdResultsResultIdComplianceOverTimeGet(id: string, resultId: string, options?: AxiosRequestConfig) {
    return PlanApiFp(this.configuration)
      .planIdResultsResultIdComplianceOverTimeGet(id, resultId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Return the compliance status by targets of the result with the given ID.
   * @summary Return the compliance status by targets
   * @param {string} id Plan ID
   * @param {string} resultId Result ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PlanApi
   */
  public planIdResultsResultIdComplianceStatusByTargetsGet(id: string, resultId: string, options?: AxiosRequestConfig) {
    return PlanApiFp(this.configuration)
      .planIdResultsResultIdComplianceStatusByTargetsGet(id, resultId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Return the findings of the result with the given ID.
   * @summary Return the findings
   * @param {string} id Plan ID
   * @param {string} resultId Result ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PlanApi
   */
  public planIdResultsResultIdFindingsGet(id: string, resultId: string, options?: AxiosRequestConfig) {
    return PlanApiFp(this.configuration)
      .planIdResultsResultIdFindingsGet(id, resultId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Return the observations of the result with the given ID.
   * @summary Return the observations
   * @param {string} id Plan ID
   * @param {string} resultId Result ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PlanApi
   */
  public planIdResultsResultIdObservationsGet(id: string, resultId: string, options?: AxiosRequestConfig) {
    return PlanApiFp(this.configuration)
      .planIdResultsResultIdObservationsGet(id, resultId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Return the remediation versus time of the result with the given ID.
   * @summary Return the remediation versus time
   * @param {string} id Plan ID
   * @param {string} resultId Result ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PlanApi
   */
  public planIdResultsResultIdRemediationVsTimeGet(id: string, resultId: string, options?: AxiosRequestConfig) {
    return PlanApiFp(this.configuration)
      .planIdResultsResultIdRemediationVsTimeGet(id, resultId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Return the risks of the result with the given ID.
   * @summary Return the risks
   * @param {string} id Plan ID
   * @param {string} resultId Result ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PlanApi
   */
  public planIdResultsResultIdRisksGet(id: string, resultId: string, options?: AxiosRequestConfig) {
    return PlanApiFp(this.configuration)
      .planIdResultsResultIdRisksGet(id, resultId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Return the summary of the result with the given ID.
   * @summary Return the result summary
   * @param {string} id Plan ID
   * @param {string} resultId Result ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PlanApi
   */
  public planIdResultsResultIdSummaryGet(id: string, resultId: string, options?: AxiosRequestConfig) {
    return PlanApiFp(this.configuration)
      .planIdResultsResultIdSummaryGet(id, resultId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * This method creates a new task and adds it to a specific plan.
   * @summary Creates a new task for a specific plan
   * @param {string} id Plan ID
   * @param {HandlerCreateTaskRequest} handlerCreateTaskRequest Task to add
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PlanApi
   */
  public planIdTasksPost(id: string, handlerCreateTaskRequest: HandlerCreateTaskRequest, options?: AxiosRequestConfig) {
    return PlanApiFp(this.configuration)
      .planIdTasksPost(id, handlerCreateTaskRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * This function is used to create an activity for a given task.
   * @summary Create activity
   * @param {number} id Plan ID
   * @param {number} taskId Task ID
   * @param {HandlerCreateActivityRequest} handlerCreateActivityRequest Activity
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PlanApi
   */
  public planIdTasksTaskIdActivitiesPost(
    id: number,
    taskId: number,
    handlerCreateActivityRequest: HandlerCreateActivityRequest,
    options?: AxiosRequestConfig,
  ) {
    return PlanApiFp(this.configuration)
      .planIdTasksTaskIdActivitiesPost(id, taskId, handlerCreateActivityRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Creates a new plan in the system
   * @summary Create a plan
   * @param {HandlerCreatePlanRequest} handlerCreatePlanRequest Plan to add
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PlanApi
   */
  public planPost(handlerCreatePlanRequest: HandlerCreatePlanRequest, options?: AxiosRequestConfig) {
    return PlanApiFp(this.configuration)
      .planPost(handlerCreatePlanRequest, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * SSPApi - axios parameter creator
 * @export
 */
export const SSPApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * List all SSP
     * @summary List all SSPs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiSspGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/ssp`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Delete an SSP with the given ID
     * @summary Delete an SSP
     * @param {string} id SSP ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiSspIdDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("apiSspIdDelete", "id", id);
      const localVarPath = `/api/ssp/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get an SSP by its ID
     * @summary Get an SSP by ID
     * @param {string} id SSP ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiSspIdGet: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("apiSspIdGet", "id", id);
      const localVarPath = `/api/ssp/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Update an SSP with the given ID
     * @summary Update an SSP
     * @param {string} id SSP ID
     * @param {HandlerUpdateSSPRequest} handlerUpdateSSPRequest SSP to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiSspIdPut: async (
      id: string,
      handlerUpdateSSPRequest: HandlerUpdateSSPRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("apiSspIdPut", "id", id);
      // verify required parameter 'handlerUpdateSSPRequest' is not null or undefined
      assertParamExists("apiSspIdPut", "handlerUpdateSSPRequest", handlerUpdateSSPRequest);
      const localVarPath = `/api/ssp/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        handlerUpdateSSPRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SSPApi - functional programming interface
 * @export
 */
export const SSPApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = SSPApiAxiosParamCreator(configuration);
  return {
    /**
     * List all SSP
     * @summary List all SSPs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiSspGet(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DomainSystemSecurityPlan>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.apiSspGet(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Delete an SSP with the given ID
     * @summary Delete an SSP
     * @param {string} id SSP ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiSspIdDelete(
      id: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.apiSspIdDelete(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Get an SSP by its ID
     * @summary Get an SSP by ID
     * @param {string} id SSP ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiSspIdGet(
      id: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DomainSystemSecurityPlan>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.apiSspIdGet(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Update an SSP with the given ID
     * @summary Update an SSP
     * @param {string} id SSP ID
     * @param {HandlerUpdateSSPRequest} handlerUpdateSSPRequest SSP to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiSspIdPut(
      id: string,
      handlerUpdateSSPRequest: HandlerUpdateSSPRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DomainSystemSecurityPlan>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.apiSspIdPut(id, handlerUpdateSSPRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * SSPApi - factory interface
 * @export
 */
export const SSPApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = SSPApiFp(configuration);
  return {
    /**
     * List all SSP
     * @summary List all SSPs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiSspGet(options?: any): AxiosPromise<DomainSystemSecurityPlan> {
      return localVarFp.apiSspGet(options).then(request => request(axios, basePath));
    },
    /**
     * Delete an SSP with the given ID
     * @summary Delete an SSP
     * @param {string} id SSP ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiSspIdDelete(id: string, options?: any): AxiosPromise<string> {
      return localVarFp.apiSspIdDelete(id, options).then(request => request(axios, basePath));
    },
    /**
     * Get an SSP by its ID
     * @summary Get an SSP by ID
     * @param {string} id SSP ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiSspIdGet(id: string, options?: any): AxiosPromise<DomainSystemSecurityPlan> {
      return localVarFp.apiSspIdGet(id, options).then(request => request(axios, basePath));
    },
    /**
     * Update an SSP with the given ID
     * @summary Update an SSP
     * @param {string} id SSP ID
     * @param {HandlerUpdateSSPRequest} handlerUpdateSSPRequest SSP to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiSspIdPut(
      id: string,
      handlerUpdateSSPRequest: HandlerUpdateSSPRequest,
      options?: any,
    ): AxiosPromise<DomainSystemSecurityPlan> {
      return localVarFp.apiSspIdPut(id, handlerUpdateSSPRequest, options).then(request => request(axios, basePath));
    },
  };
};

/**
 * SSPApi - object-oriented interface
 * @export
 * @class SSPApi
 * @extends {BaseAPI}
 */
export class SSPApi extends BaseAPI {
  /**
   * List all SSP
   * @summary List all SSPs
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SSPApi
   */
  public apiSspGet(options?: AxiosRequestConfig) {
    return SSPApiFp(this.configuration)
      .apiSspGet(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Delete an SSP with the given ID
   * @summary Delete an SSP
   * @param {string} id SSP ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SSPApi
   */
  public apiSspIdDelete(id: string, options?: AxiosRequestConfig) {
    return SSPApiFp(this.configuration)
      .apiSspIdDelete(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Get an SSP by its ID
   * @summary Get an SSP by ID
   * @param {string} id SSP ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SSPApi
   */
  public apiSspIdGet(id: string, options?: AxiosRequestConfig) {
    return SSPApiFp(this.configuration)
      .apiSspIdGet(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Update an SSP with the given ID
   * @summary Update an SSP
   * @param {string} id SSP ID
   * @param {HandlerUpdateSSPRequest} handlerUpdateSSPRequest SSP to update
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SSPApi
   */
  public apiSspIdPut(id: string, handlerUpdateSSPRequest: HandlerUpdateSSPRequest, options?: AxiosRequestConfig) {
    return SSPApiFp(this.configuration)
      .apiSspIdPut(id, handlerUpdateSSPRequest, options)
      .then(request => request(this.axios, this.basePath));
  }
}
